"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTTPSCRAMAuth = void 0;
const errors_1 = require("./errors");
const buffer_1 = require("./primitives/buffer");
const scram_1 = require("./scram");
const AUTH_ENDPOINT = "/auth/token";
function utf8ToB64(str) {
    return (0, buffer_1.encodeB64)(buffer_1.utf8Encoder.encode(str));
}
function b64ToUtf8(str) {
    return buffer_1.utf8Decoder.decode((0, buffer_1.decodeB64)(str));
}
async function HTTPSCRAMAuth(baseUrl, username, password) {
    const authUrl = baseUrl + AUTH_ENDPOINT;
    const clientNonce = await (0, scram_1.generateNonce)();
    const [clientFirst, clientFirstBare] = (0, scram_1.buildClientFirstMessage)(clientNonce, username);
    const FETCH = typeof fetch === "undefined" ? require("node-fetch") : fetch;
    const serverFirstRes = await FETCH(authUrl, {
        headers: {
            Authorization: `SCRAM-SHA-256 data=${utf8ToB64(clientFirst)}`
        }
    });
    if (serverFirstRes.status === 403) {
        console.log(serverFirstRes);
        throw new Error(`Server doesn't support HTTP SCRAM authentication`);
    }
    const firstAttrs = parseHeaders(serverFirstRes.headers, "WWW-Authenticate");
    if (firstAttrs.size === 0) {
        throw new Error("Invalid credentials");
    }
    if (!firstAttrs.has("sid") || !firstAttrs.has("data")) {
        throw new errors_1.ProtocolError(`server response doesn't contain '${!firstAttrs.has("sid") ? "sid" : "data"}' attribute`);
    }
    const sid = firstAttrs.get("sid");
    const serverFirst = b64ToUtf8(firstAttrs.get("data"));
    const [serverNonce, salt, iterCount] = (0, scram_1.parseServerFirstMessage)(serverFirst);
    const [clientFinal, expectedServerSig] = await (0, scram_1.buildClientFinalMessage)(password, salt, iterCount, clientFirstBare, serverFirst, serverNonce);
    const serverFinalRes = await FETCH(authUrl, {
        headers: {
            Authorization: `SCRAM-SHA-256 sid=${sid}, data=${utf8ToB64(clientFinal)}`
        }
    });
    if (!serverFinalRes.ok) {
        throw new Error("Invalid credentials");
    }
    const finalAttrs = parseHeaders(serverFinalRes.headers, "Authentication-Info", false);
    if (!firstAttrs.has("sid") || !firstAttrs.has("data")) {
        throw new errors_1.ProtocolError(`server response doesn't contain '${!firstAttrs.has("sid") ? "sid" : "data"}' attribute`);
    }
    if (finalAttrs.get("sid") !== sid) {
        throw new errors_1.ProtocolError("SCRAM session id does not match");
    }
    const serverFinal = b64ToUtf8(finalAttrs.get("data"));
    const serverSig = (0, scram_1.parseServerFinalMessage)(serverFinal);
    if (!(0, scram_1.bufferEquals)(serverSig, expectedServerSig)) {
        throw new errors_1.ProtocolError("server SCRAM proof does not match");
    }
    const authToken = await serverFinalRes.text();
    return authToken;
}
exports.HTTPSCRAMAuth = HTTPSCRAMAuth;
function parseHeaders(headers, headerName, checkAlgo = true) {
    const header = headers.get(headerName);
    if (!header) {
        throw new errors_1.ProtocolError(`response doesn't contain '${headerName}' header`);
    }
    let rawAttrs;
    if (checkAlgo) {
        const [algo, ..._rawAttrs] = header.split(" ");
        if (algo !== "SCRAM-SHA-256") {
            throw new errors_1.ProtocolError(`invalid scram algo '${algo}'`);
        }
        rawAttrs = _rawAttrs.join(" ");
    }
    else {
        rawAttrs = header;
    }
    return new Map(rawAttrs
        ? rawAttrs.split(",").map(attr => {
            const [key, val] = attr.split("=", 2);
            return [key.trim(), val.trim()];
        })
        : []);
}
