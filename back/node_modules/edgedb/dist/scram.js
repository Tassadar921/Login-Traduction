"use strict";
/*!
 * This source file is part of the EdgeDB open source project.
 *
 * Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.XOR = exports.getServerKey = exports.getClientKey = exports.getSaltedPassword = exports.buildClientFinalMessage = exports.parseServerFinalMessage = exports.parseServerFirstMessage = exports.buildClientFirstMessage = exports.generateNonce = exports.bufferEquals = exports.saslprep = exports.HMAC = exports.H = void 0;
const adapter_shared_node_1 = require("./adapter.shared.node");
Object.defineProperty(exports, "H", { enumerable: true, get: function () { return adapter_shared_node_1.H; } });
Object.defineProperty(exports, "HMAC", { enumerable: true, get: function () { return adapter_shared_node_1.HMAC; } });
const buffer_1 = require("./primitives/buffer");
const errors_1 = require("./errors");
const RAW_NONCE_LENGTH = 18;
function saslprep(str) {
    return str.normalize("NFKC");
}
exports.saslprep = saslprep;
function bufferEquals(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0, len = a.length; i < len; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
exports.bufferEquals = bufferEquals;
function generateNonce(length = RAW_NONCE_LENGTH) {
    return (0, adapter_shared_node_1.randomBytes)(length);
}
exports.generateNonce = generateNonce;
function buildClientFirstMessage(clientNonce, username) {
    const bare = `n=${saslprep(username)},r=${(0, buffer_1.encodeB64)(clientNonce)}`;
    return [`n,,${bare}`, bare];
}
exports.buildClientFirstMessage = buildClientFirstMessage;
function parseServerFirstMessage(msg) {
    const attrs = msg.split(",");
    if (attrs.length < 3) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const nonceAttr = attrs[0];
    if (!nonceAttr || nonceAttr[0] !== "r") {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const nonceB64 = nonceAttr.split("=", 2)[1];
    if (!nonceB64) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const nonce = (0, buffer_1.decodeB64)(nonceB64);
    const saltAttr = attrs[1];
    if (!saltAttr || saltAttr[0] !== "s") {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const saltB64 = saltAttr.split("=", 2)[1];
    if (!saltB64) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const salt = (0, buffer_1.decodeB64)(saltB64);
    const iterAttr = attrs[2];
    if (!iterAttr || iterAttr[0] !== "i") {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const iter = iterAttr.split("=", 2)[1];
    if (!iter || !iter.match(/^[0-9]*$/)) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const iterCount = parseInt(iter, 10);
    if (iterCount <= 0) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    return [nonce, salt, iterCount];
}
exports.parseServerFirstMessage = parseServerFirstMessage;
function parseServerFinalMessage(msg) {
    const attrs = msg.split(",");
    if (attrs.length < 1) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const nonceAttr = attrs[0];
    if (!nonceAttr || nonceAttr[0] !== "v") {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    const signatureB64 = nonceAttr.split("=", 2)[1];
    if (!signatureB64) {
        throw new errors_1.ProtocolError("malformed SCRAM message");
    }
    return (0, buffer_1.decodeB64)(signatureB64);
}
exports.parseServerFinalMessage = parseServerFinalMessage;
async function buildClientFinalMessage(password, salt, iterations, clientFirstBare, serverFirst, serverNonce) {
    const clientFinal = `c=biws,r=${(0, buffer_1.encodeB64)(serverNonce)}`;
    const authMessage = buffer_1.utf8Encoder.encode(`${clientFirstBare},${serverFirst},${clientFinal}`);
    const saltedPassword = await getSaltedPassword(buffer_1.utf8Encoder.encode(saslprep(password)), salt, iterations);
    const clientKey = await getClientKey(saltedPassword);
    const storedKey = await (0, adapter_shared_node_1.H)(clientKey);
    const clientSignature = await (0, adapter_shared_node_1.HMAC)(storedKey, authMessage);
    const clientProof = XOR(clientKey, clientSignature);
    const serverKey = await getServerKey(saltedPassword);
    const serverProof = await (0, adapter_shared_node_1.HMAC)(serverKey, authMessage);
    return [`${clientFinal},p=${(0, buffer_1.encodeB64)(clientProof)}`, serverProof];
}
exports.buildClientFinalMessage = buildClientFinalMessage;
async function getSaltedPassword(password, salt, iterations) {
    const msg = new Uint8Array(salt.length + 4);
    msg.set(salt);
    msg.set([0, 0, 0, 1], salt.length);
    let Hi = await (0, adapter_shared_node_1.HMAC)(password, msg);
    let Ui = Hi;
    for (let _ = 0; _ < iterations - 1; _++) {
        Ui = await (0, adapter_shared_node_1.HMAC)(password, Ui);
        Hi = XOR(Hi, Ui);
    }
    return Hi;
}
exports.getSaltedPassword = getSaltedPassword;
function getClientKey(saltedPassword) {
    return (0, adapter_shared_node_1.HMAC)(saltedPassword, buffer_1.utf8Encoder.encode("Client Key"));
}
exports.getClientKey = getClientKey;
function getServerKey(saltedPassword) {
    return (0, adapter_shared_node_1.HMAC)(saltedPassword, buffer_1.utf8Encoder.encode("Server Key"));
}
exports.getServerKey = getServerKey;
function XOR(a, b) {
    const len = a.length;
    if (len !== b.length) {
        throw new errors_1.ProtocolError("scram.XOR: buffers are of different lengths");
    }
    const res = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        res[i] = a[i] ^ b[i];
    }
    return res;
}
exports.XOR = XOR;
